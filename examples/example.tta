// used_after_move := 123;
// tmp00 := used_after_move;
// tmp01 := used_after_move;

// used_before_init : U64;
// tmp02 := used_before_init;

// tmp03 := not_declared;

// tmp04 : Unknown_type;

// already_defined_val := 123;
// already_defined_val := 456;

// already_defined_type : U64;
// already_defined_type : U64;

// conflicting_value : Foo = 123;

func := a: U64 => b: U64 => c: U64->() => c a;

a := func 1;
b := a 2;
c := b (x: U64 => x);

println := (message: U64) => {
    x := 5;
    y := 5;
    message
};

// super : (U64,)    = (1,);
// sub   : (U64,U64) = (1,2);
//
// func := x: (U64,U64) => 5;
//
// func(5);

// foo [1,2,3] ;
// foo([1,2,3]);
//
// foo    (foo, bar).baz;
//
//
// foo bar(baz);
//
//   foo  bar ;
//   foo (bar);
//  (foo) bar ;
//  (foo)(bar);
//
//  foo (5);
//  foo (bar, baz) (5);
//
//  foo(bar);
//  foo(5);
//  foo bar;
//  foo 5;
//
//  foo bar 5;
//  foo bar baz;
//
//  foo.bar(baz);
//  foo.bar baz;
//  foo.bar(5);
//  foo.bar 5;
//
// foo(bar).baz; // (foo(bar)).baz
// foo bar.baz;  // foo(bar.baz)
//
// foo bar (baz); // foo(bar(baz))
// foo(bar)(baz); // foo(bar)(baz)

//    foo bar   f(1, 2, 3).baz;
//((foo(bar))(5))((1, 2, 3).baz);
//

// foo + bar.baz;
//     bar  baz ;
//     bar (baz);
//    (bar) baz ;
//    (bar)(baz);
// foo(bar)(baz);
//
// (foo) bar .baz;
// (foo)(bar).baz;
//
//
//
// foo(bar)(baz)
//
// foo a + b

foo [5];
foo([5]);

one_tup := (1,);
foo := (x:U64, y:U64) => 5;
bar := (t:(U64,U64)) => 5;
//baz := (f:(U64,U64)) => U64 { () };
baz foo; // foo takes 2 int arguments
baz bar; // bar takes 1 (int,int) argument
first := (x:U64[]) => x[0];
a := (x:U64)=>[x];
get_name := x => x.name;
compose :: (f: $A->$B, g: B->$C) => x => g f x;

compose :: (f: $A->$B, g: B->$C) => A->C {
    (x: A) => C {
        g(f(x))
    }
};

foo :: x: U64[] => ((),(),) {
    123
};

do_nothing :: () => ((),()) { () };

unit :: () {

};

(a : ()) => ();
(a : (())) => ();
(a : ((),())) => ();
(a : (XX,())) => ();
(a : ((),XX)) => ();
(a : (XX,XX)) => ();
((),(),());
(12,(),());
((),12,());
(12,12,());
((),(),12);
(12,(),12);
((),12,12);
(12,12,12);
(ab,(),());
((),ab,());
(ab,ab,());
((),(),ab);
(ab,(),ab);
((),ab,ab);
(ab,ab,ab);

((),())[123];

v1 'cross v2; // desugars to cross(v1, v2);

a b 'c d e;
- b 'c d e;

foo ::(((()),1));
foo :
(
    (
        (
            (),
            ()
        ),
    )
) = 1;
