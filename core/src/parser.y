%require "3.7"
%language "C++"
%locations
%defines
%parse-param {class Scanner &scanner}
%parse-param {std::vector<print::Message> &errors}
%parse-param {std::vector<std::unique_ptr<AST::Expression>> &ast_out}
%parse-param {bool &failed}

%define api.namespace {yy}
%define api.parser.class {Parser}
%define api.token.constructor
%define api.value.type variant
%define api.value.automove
%define parse.assert
%define parse.trace
%define parse.error custom
%define parse.lac full
%define api.token.prefix {TOK_}

%code requires {
// This block is inserted at the top of parser.hpp

// Disable compiler-specific warnings for code generated by Bison
#if defined(__clang__)
#    pragma clang diagnostic push
#elif defined(__GNUC__) || defined(__GNUG__)
#    pragma GCC diagnostic push
#elif defined(_MSC_VER)
#    pragma warning(push)
#    pragma warning(disable:                                                                                           \
         4065 /* switch statement contains 'default' but no 'case' labels */                                           \
     )
#endif

#include <optional>

#include "ast/ast_includes.hpp"
#include "printer.hpp"

} // %code requires

%code provides {
// This block is inserted at the bottom of parser.hpp

#if defined(__clang__)
#    pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#    pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#    pragma warning(pop)
#endif

} // %code provides

%{
// This block is inserted at the top of parser.cpp

// Disable compiler-specific warnings for code generated by Bison
#if defined(__clang__)
#elif defined(__GNUC__) || defined(__GNUG__)
#elif defined(_MSC_VER)
#    pragma warning(disable:                                                                                           \
         4065 /* switch statement contains 'default' but no 'case' labels */                                           \
         4127 /* conditional expression is constant */                                                                 \
         4244 /* 'return': conversion from 'std::streamsize' to 'int', possible loss of data */                        \
     )
#endif

#include "scanner.hpp"

#define yylex scanner.scan

#define NODE(type, ...) std::make_unique<AST:: type>(__VA_ARGS__)

%}

%initial-action {
    // Invoked before parsing each time parse() is called.
}

/* TOKENS */
%token
    EOF 0       "end of file"
    LPAREN      "("
    RPAREN      ")"
    LBRACE      "{"
    RBRACE      "}"
    LBRACKET    "["
    RBRACKET    "]"
    SEMICOLON   ";"
    TYPE_DECL   ":"
    DEFINE      ":="
    ASSIGN      "="
    COMMA       ","
    ARROW       "->"
    BIG_ARROW   "=>"

%token< uint64_t >
    U64         "`U64` literal"

%token< std::string >
    IDENT       "identifier"
    TYPENAME    "type name"

%type< std::vector<std::unique_ptr<AST::Expression>> >
    opt_lines
    lines
    multi_tuple
    tuple_values
    multi_array
    opt_expressions
    expressions

%type< std::unique_ptr<AST::Expression> >
    line
    expression
    func_expression
    call_expression
    tuple_expression
    simple_expression

%type< std::unique_ptr<AST::Definition> >
    definition

%type< std::unique_ptr<AST::Literal> >
    literal

%type< std::unique_ptr<AST::Block> >
    block

%type< std::unique_ptr<AST::Type> >
    type
    func_type
    tuple_type
    simple_type

%type< std::vector<std::unique_ptr<AST::Type>> >
    tuple_types
    types

%type< AST::Function::arg_t >
    arg_type

%type< std::vector<AST::Function::arg_t> >
    opt_arg_types
    arg_types

%start file

%%

file
    : opt_lines {
        ast_out = $1;
    }

opt_lines
    : %empty {}
    | lines

lines
    : line {
        $$.emplace_back($1);
    }
    | lines line {
        $$ = $1;
        $$.emplace_back($2);
    }

line
    : expression ";" {
        $$ = $1;
    }
    | definition ";" {
        $$ = $1;
    }
    | "identifier" ":=" error ";" {
        failed = true;
        $$ = NODE(ValueDefinition, $1, @1, NODE(Error, @3), @$);
    }
    | "identifier" ":=" expression error ";" {
        failed = true;
        $$ = NODE(ValueDefinition, $1, @1, $3, @$);
    }
    | "identifier" ":" type error ";" {
        failed = true;
        $$ = NODE(TypeDefinition, $1, @1, $3, @$);
    }
    | "identifier" ":" error ";" {
        failed = true;
        $$ = NODE(TypeDefinition, $1, @1, NODE(Error, @3), @$);
    }
    | error ";" {
        failed = true;
        $$ = NODE(Error, @1);
    }

expression
    : func_expression {
        $$ = $1;
    }

definition
    : "identifier" ":=" expression {
        $$ = NODE(ValueDefinition, $1, @1, $3, @$);
    }
    | "identifier" ":" type {
        $$ = NODE(TypeDefinition, $1, @1, $3, @$);
    }
    | "identifier" ":" type "=" expression {
        $$ = NODE(TypeValueDefinition, $1, @1, $3, $5, @$);
    }

func_expression
    : call_expression
    | arg_type "=>" expression {
        std::vector<AST::Function::arg_t> args;
        args.emplace_back($1);
        $$ = NODE(Function, std::move(args), @1, $3, @$);
    }
    | opt_arg_types "=>" expression {
        $$ = NODE(Function, $1, @1, $3, @$);
    }
    | opt_arg_types "->" type "=>" expression {
        auto loc = yy::location{@1.begin, @3.end};
        $$ = NODE(Function, $1, $3, loc, $5, @$);
    }

call_expression
    : tuple_expression
    | call_expression simple_expression {
        auto values = std::vector<std::unique_ptr<AST::Expression>>();
        values.emplace_back($2);
        $$ = NODE(Call, $1, std::move(values), @2, @$);
    }
    | call_expression multi_tuple {
        $$ = NODE(Call, $1, $2, @2, @$);
    }

tuple_expression
    : simple_expression
    | multi_tuple {
        $$ = NODE(Tuple, $1, @$);
    }
    | multi_array {
        $$ = NODE(Array, $1, @$);
    }

simple_expression
    : literal {
        $$ = $1;
    }
    | "identifier" {
        $$ = NODE(Variable, $1, @$);
    }
    | block {
        $$ = $1;
    }
    | simple_expression "[" expression "]" {
        $$ = NODE(Index, $1, $3, @$);
    }
    | "(" expression opt_comma ")" {
        // optional comma to emulate a 1-tuple,
        // but its value should still just be the contained value
        $$ = $2;
    }

multi_tuple
    : "(" tuple_values opt_comma ")" {
        $$ = $2;
    }
    | unit {}

multi_array
    : "[" opt_expressions "]" {
        $$ = $2;
    }

opt_expressions
    : %empty {}
    | expressions

expressions
    : expression {
        $$.emplace_back($1);
    }
    | expressions "," expression {
        $$ = $1;
        $$.emplace_back($3);
    }
    | error {}
    | expressions "," error {
        $$ = $1;
    }

tuple_values
    : expression "," expression {
        $$.push_back($1);
        $$.push_back($3);
    }
    | tuple_values "," expression {
        $$ = $1;
        $$.push_back($3);
    }
    | tuple_values "," error {
        failed = true;
        $$ = $1;
    }
    | expression "," error {
        failed = true;
        $$.push_back($1);
    }

unit
    : "(" ")"

block
    : "{" "}" {
        $$ = NODE(Block, @$, @$);
    }
    | "{" expression "}" {
        $$ = NODE(Block, $2, @$);
    }
    | "{" expression ";" "}" {
        std::vector<std::unique_ptr<AST::Expression>> lines;
        lines.push_back($2);
        $$ = NODE(Block, std::move(lines), @3, @$);
    }
    | "{" lines expression "}" {
        $$ = NODE(Block, $2, $3, @$);
    }
    | "{" lines expression ";" "}" {
        auto lines = $2;
        lines.push_back($3);
        $$ = NODE(Block, std::move(lines), @4, @$);
    }

literal
    : "`U64` literal" {
        $$ = NODE(U64, $1, @$);
    }

opt_arg_types
    : unit {}
    | "(" arg_types ")" {
        $$ = $2;
    }

arg_types
    : arg_type {
        $$.push_back($1);
    }
    | arg_types "," arg_type {
        $$ = $1;
        $$.push_back($3);
    }
    | error {
        failed = true;
    }
    | arg_types "," error {
        failed = true;
        $$ = $1;
    }

arg_type
    : "identifier" ":" type {
        auto pattern = AST::Function::Pattern{$1, $3};
        $$ = std::make_pair(std::move(pattern), @$);
    }

type
    : tuple_type
    | func_type

tuple_type
    : simple_type
    | tuple_types {
        $$ = NODE(TupleType, $1, @$);
    }

func_type
    : simple_type "->" type {
        auto types = std::vector<std::unique_ptr<AST::Type>>();
        types.push_back($1);
        $$ = NODE(FuncType, std::move(types), $3, @$);
    }
    | tuple_types "->" type {
        $$ = NODE(FuncType, $1, $3, @$);
    }

simple_type
    : "type name" {
        $$ = NODE(ObjectType, $1, @1, @$);
    }
    | tuple_type "[" "]" {
        $$ = NODE(ArrayType, $1, @$);
    }
    | "(" type opt_comma ")" {
        // optional comma to emulate a 1-tuple,
        // but its type should still just be the contained type
        $$ = $2;
    }

tuple_types
    : unit {}
    | "(" types opt_comma ")" {
        $$ = $2;
    }

types
    : type "," type {
        $$.push_back($1);
        $$.push_back($3);
    }
    | types "," type {
        $$ = $1;
        $$.push_back($3);
    }
    | types "," error {
        failed = true;
        $$ = $1;
    }
    | type "," error {
        failed = true;
        $$.push_back($1);
    }

opt_comma
    : %empty
    | ","

%%

// This block is inserted at the bottom of parser.cpp

#include <iomanip>

namespace yy {

static std::vector<print::colored_text>
symbol_kind_name(const yy::Parser::symbol_kind_type &kind) {
    using namespace print;
    switch (kind) {
        case Parser::symbol_kind::S_LPAREN:
            return {
                {"`", color::bold_gray},
                {"(", color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_RPAREN:
            return {
                {"`", color::bold_gray},
                {")", color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_LBRACE:
            return {
                {"`", color::bold_gray},
                {"{", color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_RBRACE:
            return {
                {"`", color::bold_gray},
                {"}", color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_LBRACKET:
            return {
                {"`", color::bold_gray},
                {"[", color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_RBRACKET:
            return {
                {"`", color::bold_gray},
                {"]", color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_SEMICOLON:
            return {
                {"`", color::bold_gray},
                {";", color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_TYPE_DECL:
            return {
                {"`", color::bold_gray},
                {":", color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_DEFINE:
            return {
                {"`", color::bold_gray},
                {":=", color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_ASSIGN:
            return {
                {"`", color::bold_gray},
                {"=", color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_COMMA:
            return {
                {"`", color::bold_gray},
                {",", color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_ARROW:
            return {
                {"`", color::bold_gray},
                {"->", color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_BIG_ARROW:
            return {
                {"`", color::bold_gray},
                {"=>", color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_U64:
            return {{"`U64` literal", color::bold_gray}};
        case Parser::symbol_kind::S_IDENT:
            return {{"identifier", color::bold_gray}};
        case Parser::symbol_kind::S_TYPENAME:
            return {{"type name", color::bold_gray}};
        case Parser::symbol_kind::S_YYEMPTY:
        case Parser::symbol_kind::S_YYEOF:
        case Parser::symbol_kind::S_YYerror:
        case Parser::symbol_kind::S_YYUNDEF:
        case Parser::symbol_kind::S_YYACCEPT:
        case Parser::symbol_kind::S_file:
        case Parser::symbol_kind::S_opt_lines:
        case Parser::symbol_kind::S_lines:
        case Parser::symbol_kind::S_line:
        case Parser::symbol_kind::S_expression:
        case Parser::symbol_kind::S_definition:
        case Parser::symbol_kind::S_func_expression:
        case Parser::symbol_kind::S_call_expression:
        case Parser::symbol_kind::S_tuple_expression:
        case Parser::symbol_kind::S_simple_expression:
        case Parser::symbol_kind::S_multi_tuple:
        case Parser::symbol_kind::S_tuple_values:
        case Parser::symbol_kind::S_multi_array:
        case Parser::symbol_kind::S_opt_expressions:
        case Parser::symbol_kind::S_expressions:
        case Parser::symbol_kind::S_block:
        case Parser::symbol_kind::S_literal:
        case Parser::symbol_kind::S_types:
        case Parser::symbol_kind::S_type:
        case Parser::symbol_kind::S_func_type:
        case Parser::symbol_kind::S_tuple_type:
        case Parser::symbol_kind::S_tuple_types:
        case Parser::symbol_kind::S_simple_type:
        case Parser::symbol_kind::S_opt_arg_types:
        case Parser::symbol_kind::S_arg_types:
        case Parser::symbol_kind::S_arg_type:
        case Parser::symbol_kind::S_unit:
        case Parser::symbol_kind::S_opt_comma:
            break;
    }
    return {{yy::Parser::symbol_name(kind), color::bold_gray}};
}

static std::vector<print::colored_text>
symbol_type_name(const yy::Parser::symbol_type &tok) {
    using namespace print;
    auto kind = tok.kind();
    switch (kind) {
        case Parser::symbol_kind::S_U64:
            return {
                {"`U64` literal `", color::bold_gray},
                {std::to_string(tok.value.as<std::uint64_t>()), color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_IDENT:
            return {
                {"identifier `", color::bold_gray},
                {tok.value.as<std::string>(), color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_TYPENAME:
            return {
                {"type name `", color::bold_gray},
                {tok.value.as<std::string>(), color::bold_red},
                {"`", color::bold_gray}
            };
        default:
            break;
    }
    return symbol_kind_name(kind);
}

void
Parser::report_syntax_error(yy::Parser::context const &ctx) const {
    using namespace print;

    auto &loc = ctx.location();
    // auto  tok = ctx.token();
    auto &lah = ctx.lookahead();
    auto  num = ctx.expected_tokens(nullptr, 0);
    auto  exp = std::vector<Parser::symbol_kind_type>(num);
    ctx.expected_tokens(exp.data(), num);

    auto message = Message::error(loc.begin)
                   .with_message("expected ", color::bold_gray);
    std::string sep;
    for (int i = 0; i < static_cast<int>(exp.size()) - 1; i++) {
        message.with_message(sep, color::bold_gray);
        for (auto s : symbol_kind_name(exp[i])) {
            message.with_message(s);
        }
        sep = ", ";
    }
    if (exp.size() > 1) {
        message.with_message(" or ", color::bold_gray);
    }
    for (auto s : symbol_kind_name(exp.back())) {
        message.with_message(s);
    }
    message.with_message(", found ", color::bold_gray);
    for (auto s : symbol_type_name(lah)) {
        message.with_message(s);
    }
    message.with_detail(loc, color::bold_red)
           .with_message("unexpected ", color::bold_gray);
    for (auto m : symbol_type_name(lah)) {
        message.with_message(m);
    }
    errors.push_back(message);
    failed = true;
}

void
Parser::error(const location &loc, const std::string &message) {
    using namespace print;
    errors.push_back(
        Message::error(loc.begin)
                .with_message(message, color::bold_gray)
                .with_detail(loc, color::bold_red)
                .with_message(message, color::bold_gray)
    );
}

} // namespace yy
