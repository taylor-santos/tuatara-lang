%require "3.7"
%language "C++"
%locations
%defines
%parse-param {class Scanner &scanner}
%parse-param {std::vector<print::Message> &errors}
%parse-param {std::vector<std::unique_ptr<AST::Expression>> &ast_out}
%parse-param {bool &failed}

%define api.namespace {yy}
%define api.parser.class {Parser}
%define api.token.constructor
%define api.value.type variant
%define api.value.automove
%define parse.assert
%define parse.trace
%define parse.error custom
%define parse.lac full
%define api.token.prefix {TOK_}

%code requires {
// This block is inserted at the top of parser.hpp

// Disable compiler-specific warnings for code generated by Bison
#if defined(__clang__)
#    pragma clang diagnostic push
#elif defined(__GNUC__) || defined(__GNUG__)
#    pragma GCC diagnostic push
#elif defined(_MSC_VER)
#    pragma warning(push)
#    pragma warning(disable:                                                                                           \
         4065 /* switch statement contains 'default' but no 'case' labels */                                           \
     )
#endif

#include <optional>

#include "ast/ast_includes.hpp"
#include "printer.hpp"

} // %code requires

%code provides {
// This block is inserted at the bottom of parser.hpp

#if defined(__clang__)
#    pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#    pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#    pragma warning(pop)
#endif

} // %code provides

%{
// This block is inserted at the top of parser.cpp

// Disable compiler-specific warnings for code generated by Bison
#if defined(__clang__)
#elif defined(__GNUC__) || defined(__GNUG__)
#elif defined(_MSC_VER)
#    pragma warning(disable:                                                                                           \
         4065 /* switch statement contains 'default' but no 'case' labels */                                           \
         4127 /* conditional expression is constant */                                                                 \
         4244 /* 'return': conversion from 'std::streamsize' to 'int', possible loss of data */                        \
     )
#endif

#include "scanner.hpp"

#define yylex scanner.scan

#define NODE(type, ...) std::make_unique<AST:: type>(__VA_ARGS__)

%}

%initial-action {
    // Invoked before parsing each time parse() is called.
}

/* TOKENS */
%token
    EOF 0       "end of file"
    RETURN      "return"
    STRUCT      "struct"
    OPERATOR    "operator"
    LPAREN      "("
    RPAREN      ")"
    LBRACE      "{"
    RBRACE      "}"
    LBRACKET    "["
    RBRACKET    "]"
    SEMICOLON   ";"
    TYPE_DECL   ":"
    DEFINE      ":="
    CONSTDEF    "::"
    ASSIGN      "="
    COMMA       ","
    DOT         "."
    TICK        "'"
    ARROW       "->"
    BIGARROW    "=>"
    DOLLAR      "$"
    BANG        "!"
    TILDE       "~"
    MUL         "*"
    DIV         "/"
    MOD         "%"
    PLUS        "+"
    MINUS       "-"
    LSHIFT      "<<"
    RSHIFT      ">>"
    LT          "<"
    LE          "<="
    GT          ">"
    GE          ">="
    EQ          "=="
    NE          "!="
    BITAND      "&"
    BITXOR      "^"
    BITOR       "|"
    AND         "&&"
    OR          "||"
    UNINIT      "---"

%token< uint64_t >
    INT         "Int"

%token< std::string >
    IDENT       "identifier"
    TYPENAME    "type name"
    SYMBOL      "symbol"

%type< std::stringstream >
    opt_lines
    lines
    line
    block_line
    expression
    op_expr
    operand
    block_expr
    apply_expr
    simple_expr
    no_paren_simple_expr
    paren_simple_expr
    block
    tuple
    no_id_expr
    opt_struct_fields
    struct_fields
    struct_field
    opt_exprs
    exprs
    op_def
    func_sig
    no_id_args
    no_id_exprs
    no_id_arg
    arg
    types
    type
    or_types
    func_type
    ptr_type
    simple_type
    array
    ident_array
    idents
    ident

%left "||"
%left "&&"
%left "|"
%left "^"
%left "&"
%left "==" "!="
%left "<" "<=" ">" ">="
%left "<<" ">>"
%left "+" "-"
%left "*" "/" "%"
%left "symbol" "'"
%precedence UNARY

%start file

%%

file
    : opt_lines                                                 { std::cout << $1.str(); }

opt_lines
    : %empty {}
    | lines

lines
    : line
    | block_line
    | ";"                                                       { }
    | lines line                                                { ($$ = $1) << $2.str(); }
    | lines block_line                                          { ($$ = $1) << $2.str(); }
    | lines ";"                                                 { ($$ = $1); }

line
    : no_id_expr ";"                                            { ($$ = $1) << ";\n"; }
    | ident      ";"                                            { ($$ = $1) << ";\n"; }
    | "return" no_id_expr ";"                                   { $$ << "return (" << $2.str() << ");\n"; }
    | "return" ident      ";"                                   { $$ << "return (" << $2.str() << ");\n"; }
    | ident  ":="         no_id_expr ";"                        { ($$ = $1) << " := (" << $3.str() << ");\n"; }
    | ident  ":="         ident      ";"                        { ($$ = $1) << " := (" << $3.str() << ");\n"; }
    | ident  "::"         no_id_expr ";"                        { ($$ = $1) << " :: (" << $3.str() << ");\n"; }
    | ident  "::"         ident      ";"                        { ($$ = $1) << " :: (" << $3.str() << ");\n"; }
    | ident  ":" type ":" no_id_expr ";"                        { ($$ = $1) << ": (" << $3.str() << ") = (" << $5.str() << ");\n"; }
    | ident  ":" type ":" ident      ";"                        { ($$ = $1) << ": (" << $3.str() << ") = (" << $5.str() << ");\n"; }
    | ident  ":" type "=" no_id_expr ";"                        { ($$ = $1) << ": (" << $3.str() << ") = (" << $5.str() << ");\n"; }
    | ident  ":" type "=" ident      ";"                        { ($$ = $1) << ": (" << $3.str() << ") = (" << $5.str() << ");\n"; }
    | ident  ":" type "=" "---"      ";"                        { ($$ = $1) << ": (" << $3.str() << ") = ---;\n"; }
    | op_def ":="         no_id_expr ";"                        { ($$ = $1) << " := (" << $3.str() << ");\n"; }
    | op_def ":="         ident      ";"                        { ($$ = $1) << " := (" << $3.str() << ");\n"; }
    | op_def "::"         no_id_expr ";"                        { ($$ = $1) << " :: (" << $3.str() << ");\n"; }
    | op_def "::"         ident      ";"                        { ($$ = $1) << " :: (" << $3.str() << ");\n"; }
    | op_def ":" type "=" no_id_expr ";"                        { ($$ = $1) << ": (" << $3.str() << ") = (" << $5.str() << ");\n"; }
    | op_def ":" type "=" ident      ";"                        { ($$ = $1) << ": (" << $3.str() << ") = (" << $5.str() << ");\n"; }
    | error ";"                                                 { $$ << "<ERROR>;\n"; yyerrok; }

block_line
    : block_expr
    | "return" block_expr                                       { $$ << "return (" << $2.str() << ");\n"; }
    | "type name" "::" "struct" "{" opt_struct_fields "}"       { $$ << $1  << " :: struct {\n" << $5.str() << "}\n"; }
    | ident  ":="         block_expr                            { ($$ = $1) << " := "  << $3.str() << "\n"; }
    | ident  "::"         block_expr                            { ($$ = $1) << " :: (" << $3.str() << ");\n"; }
    | ident  ":" type ":" block_expr                            { ($$ = $1) << ": (" << $3.str() << ") = (" << $5.str() << ");\n"; }
    | ident  ":" type "=" block_expr                            { ($$ = $1) << ": (" << $3.str() << ") = (" << $5.str() << ");\n"; }
    | op_def ":="         block_expr                            { ($$ = $1) << " := (" << $3.str() << ");\n"; }
    | op_def "::"         block_expr                            { ($$ = $1) << " :: (" << $3.str() << ");\n"; }
    | op_def ":" type "=" block_expr                            { ($$ = $1) << ": (" << $3.str() << ") = (" << $5.str() << ");\n"; }

expression
    : no_id_expr
    | block_expr
    | ident

no_id_expr
    : apply_expr
    | op_expr
    | array
    | func_sig no_id_expr                                       { ($$ = $1) << $2.str(); }
    | func_sig ident                                            { ($$ = $1) << $2.str(); }

op_def
    : "operator" simple_type "[" types opt_comma "]"            { $$ << "(" << $2.str() << ")[]"; }
    | "operator" simple_type "(" types opt_comma ")"            { $$ << "(" << $2.str() << ")()"; }
    | "operator" simple_type "*"      simple_type               { $$ << "*"; }
    | "operator" simple_type "/"      simple_type               { $$ << "/"; }
    | "operator" simple_type "%"      simple_type               { $$ << "%"; }
    | "operator" simple_type "+"      simple_type               { $$ << "+"; }
    | "operator" simple_type "-"      simple_type               { $$ << "-"; }
    | "operator" simple_type "<<"     simple_type               { $$ << "<<"; }
    | "operator" simple_type ">>"     simple_type               { $$ << ">>"; }
    | "operator" simple_type "<"      simple_type               { $$ << "<"; }
    | "operator" simple_type "<="     simple_type               { $$ << "<="; }
    | "operator" simple_type ">"      simple_type               { $$ << ">"; }
    | "operator" simple_type ">="     simple_type               { $$ << ">="; }
    | "operator" simple_type "=="     simple_type               { $$ << "=="; }
    | "operator" simple_type "!="     simple_type               { $$ << "!="; }
    | "operator" simple_type "&"      simple_type               { $$ << "&"; }
    | "operator" simple_type "^"      simple_type               { $$ << "^"; }
    | "operator" simple_type "|"      simple_type               { $$ << "|"; }
    | "operator" simple_type "&&"     simple_type               { $$ << "&&"; }
    | "operator" simple_type "||"     simple_type               { $$ << "||"; }
    | "operator" simple_type "~"      simple_type               { $$ << "~"; }
    | "operator" simple_type "!"      simple_type               { $$ << "!"; }
    | "operator" simple_type "symbol" simple_type               { $$ << $3; }

opt_struct_fields
    : %empty {}
    | struct_fields

struct_fields
    : struct_field
    | struct_fields struct_field                                { ($$ = $1) << $2.str(); }

struct_field
    : ident  ":="         no_id_expr ";"                        { ($$ = $1) << " := " << "(" << $3.str() << ");\n"; }
    | ident  ":="         ident      ";"                        { ($$ = $1) << " := " << "(" << $3.str() << ");\n"; }
    | ident  ":="         block_expr                            { ($$ = $1) << " := " << "(" << $3.str() << ");\n"; }
    | ident  "::"         no_id_expr ";"                        { ($$ = $1) << " :: " << "(" << $3.str() << ");\n"; }
    | ident  "::"         ident      ";"                        { ($$ = $1) << " :: " << "(" << $3.str() << ");\n"; }
    | ident  "::"         block_expr                            { ($$ = $1) << " :: " << "(" << $3.str() << ");\n"; }
    | ident  ":" type                ";"                        { ($$ = $1) << ": "   << "(" << $3.str() << ");\n"; }
    | ident  ":" type ":" no_id_expr ";"                        { ($$ = $1) << ": "   << "(" << $3.str() << ") = (" << $5.str() << ");\n"; }
    | ident  ":" type ":" ident      ";"                        { ($$ = $1) << ": "   << "(" << $3.str() << ") = (" << $5.str() << ");\n"; }
    | ident  ":" type ":" block_expr                            { ($$ = $1) << ": "   << "(" << $3.str() << ") = (" << $5.str() << ");\n"; }
    | ident  ":" type "=" no_id_expr ";"                        { ($$ = $1) << ": "   << "(" << $3.str() << ") = (" << $5.str() << ");\n"; }
    | ident  ":" type "=" ident      ";"                        { ($$ = $1) << ": "   << "(" << $3.str() << ") = (" << $5.str() << ");\n"; }
    | ident  ":" type "=" block_expr                            { ($$ = $1) << ": "   << "(" << $3.str() << ") = (" << $5.str() << ");\n"; }
    | ident  ":" type "=" "---"      ";"                        { ($$ = $1) << ": "   << "(" << $3.str() << ") = ---;\n"; }

block_expr
    :                       block
    |           ident_array block                               { ($$                           = $1)      << $2.str(); }
    |           "[" "]"     block                               { $$                           << "[]"     << $3.str(); }
    | func_type             block                               { $$ << "(" << $1.str() << ")"             << $2.str(); }
    | func_type ident_array block                               { $$ << "(" << $1.str() << ")" << $2.str() << $3.str(); }
    | func_type "[" "]"     block                               { $$ << "(" << $1.str() << ")" << "[]"     << $4.str(); }
    | func_sig block_expr                                       { ($$ = $1) << $2.str(); }


func_sig
    : "(" no_id_args opt_comma ")" "=>"                         { $$ << "(" << $2.str()                     << ") => "; }
    | "(" idents     opt_comma ")" "=>"                         { $$ << "(" << $2.str()                     << ") => "; }
    | "("                      ")" "=>"                         { $$ << "("                                 << ") => "; }
    | "("            ","       ")" "=>"                         { $$ << "("                                 << ") => "; }
    | ident                        "=>"                         { $$ << "(" << $1.str()                     << ") => "; }
    | ident ":" type               "=>"                         { $$ << "(" << $1.str() << ": " << $3.str() << ") => "; }

op_expr
    : operand "*"       operand                                 { $$ << "(" << $1.str() << ") * ("  << $3.str() << ")"; }
    | operand "/"       operand                                 { $$ << "(" << $1.str() << ") / ("  << $3.str() << ")"; }
    | operand "%"       operand                                 { $$ << "(" << $1.str() << ") % ("  << $3.str() << ")"; }
    | operand "+"       operand                                 { $$ << "(" << $1.str() << ") + ("  << $3.str() << ")"; }
    | operand "-"       operand                                 { $$ << "(" << $1.str() << ") - ("  << $3.str() << ")"; }
    | operand "<<"      operand                                 { $$ << "(" << $1.str() << ") << (" << $3.str() << ")"; }
    | operand ">>"      operand                                 { $$ << "(" << $1.str() << ") >> (" << $3.str() << ")"; }
    | operand "<"       operand                                 { $$ << "(" << $1.str() << ") < ("  << $3.str() << ")"; }
    | operand "<="      operand                                 { $$ << "(" << $1.str() << ") <= (" << $3.str() << ")"; }
    | operand ">"       operand                                 { $$ << "(" << $1.str() << ") > ("  << $3.str() << ")"; }
    | operand ">="      operand                                 { $$ << "(" << $1.str() << ") >= (" << $3.str() << ")"; }
    | operand "=="      operand                                 { $$ << "(" << $1.str() << ") == (" << $3.str() << ")"; }
    | operand "!="      operand                                 { $$ << "(" << $1.str() << ") != (" << $3.str() << ")"; }
    | operand "&"       operand                                 { $$ << "(" << $1.str() << ") & ("  << $3.str() << ")"; }
    | operand "^"       operand                                 { $$ << "(" << $1.str() << ") ^ ("  << $3.str() << ")"; }
    | operand "|"       operand                                 { $$ << "(" << $1.str() << ") | ("  << $3.str() << ")"; }
    | operand "&&"      operand                                 { $$ << "(" << $1.str() << ") && (" << $3.str() << ")"; }
    | operand "||"      operand                                 { $$ << "(" << $1.str() << ") || (" << $3.str() << ")"; }
    | operand "symbol"  operand                                 { $$ << "(" << $1.str() << ") "  << $2       << " (" << $3.str() << ")"; }
    | operand "'" ident operand                                 { $$ << "(" << $1.str() << ") '" << $3.str() << " (" << $4.str() << ")"; }
    |         "+"       operand %prec UNARY                     { $$ << "+" << "(" << $2.str() << ")"; }
    |         "-"       operand %prec UNARY                     { $$ << "-" << "(" << $2.str() << ")"; }
    |         "!"       operand %prec UNARY                     { $$ << "!" << "(" << $2.str() << ")"; }
    |         "~"       operand %prec UNARY                     { $$ << "~" << "(" << $2.str() << ")"; }
    |         "^"       operand %prec UNARY                     { $$ << "^" << "(" << $2.str() << ")"; }
    |         "&"       operand %prec UNARY                     { $$ << "&" << "(" << $2.str() << ")"; }
    |         "symbol"  operand %prec UNARY                     { $$ << $1  << "(" << $2.str() << ")"; }

operand
    : op_expr
    | apply_expr
    | ident

apply_expr
    : simple_expr
    | ident      no_paren_simple_expr                           { $$ << "(" << $1.str() << ")(" << $2.str() << ")"; }
    | ident      ident                                          { $$ << "(" << $1.str() << ")(" << $2.str() << ")"; }
    | apply_expr no_paren_simple_expr                           { $$ << "(" << $1.str() << ")(" << $2.str() << ")"; }
    | apply_expr ident                                          { $$ << "(" << $1.str() << ")(" << $2.str() << ")"; }

simple_expr
    : no_paren_simple_expr
    | paren_simple_expr

no_paren_simple_expr
    : no_paren_simple_expr "." ident                            { $$ << "(" << $1.str() << ")." << $3.str(); }
    | ident                "." ident                            { ($$        = $1)       << "." << $3.str(); }
    | no_paren_simple_expr tuple                                { $$ << "(" << $1.str() << ")(" << $2.str() << ")"; }
    | ident                tuple                                { $$ << "(" << $1.str() << ")(" << $2.str() << ")"; }
    | no_paren_simple_expr array                                { $$ << "(" << $1.str() << ")"  << $2.str(); }
    | ident                array                                { ($$        = $1)       << "(" << $2.str() << ")"; }
    | "Int"                                                     { $$ << $1; }
    | "type name" "(" opt_exprs ")"                             { $$ << $1 << "{" << $3.str() << "}"; }

paren_simple_expr
    : tuple                                                     { $$ << "(" << $1.str() << ")"; }
    | paren_simple_expr "." ident                               { ($$        = $1)       << "." << $3.str(); }
    | paren_simple_expr tuple                                   { ($$        = $1)       << "(" << $2.str() << ")"; }
    | paren_simple_expr array                                   { ($$        = $1)              << $2.str(); }

tuple
    : "(" no_id_exprs opt_comma ")"                             { ($$  = $2); }
    | "(" idents      opt_comma ")"                             { ($$  = $2); }
    | "("             ","       ")"                             { $$ << "(,)"; }

array
    : "[" no_id_exprs opt_comma "]"                             { $$ << "[" << $2.str() << "]"; }
    | "[" idents      ","       "]"                             { $$ << "[" << $2.str() << "]"; }
    | ident_array

ident_array
    : "[" idents "]"                                            { $$ << "[" << $2.str() << "]"; }

no_id_exprs
    : no_id_expr
    | block_expr
    | idents      "," no_id_expr                                { ($$ = $1) << ", " << $3.str(); }
    | no_id_exprs "," expression                                { ($$ = $1) << ", " << $3.str(); }

opt_exprs
    : %empty {}
    | exprs

exprs
    : expression
    | exprs "," expression                                      { ($$ = $1) << ", " << $3.str(); }

block
    : "{"                  "}"                                  { $$ << "{}\n"; }
    | "{"       ";"        "}"                                  { $$ << "{}\n"; }
    | "{"       line       "}"                                  { $$ << "{\n" << $2.str()               << "}\n"; }
    | "{"       no_id_expr "}"                                  { $$ << "{\n" << $2.str()             << "\n}\n"; }
    | "{"       ident      "}"                                  { $$ << "{\n" << $2.str()             << "\n}\n"; }
    | "{"       block_line "}"                                  { $$ << "{\n" << $2.str()               << "}\n"; }
    | "{" lines line       "}"                                  { $$ << "{\n" << $2.str() << $3.str()   << "}\n"; }
    | "{" lines no_id_expr "}"                                  { $$ << "{\n" << $2.str() << $3.str() << "\n}\n"; }
    | "{" lines ident      "}"                                  { $$ << "{\n" << $2.str() << $3.str() << "\n}\n"; }
    | "{" lines block_line "}"                                  { $$ << "{\n" << $2.str() << $3.str() <<   "}\n"; }
    | "{" lines ";"        "}"                                  { $$ << "{\n" << $2.str()             <<   "}\n"; }

arg
    : no_id_arg
    | ident

no_id_arg
    : ident ":" type                                            { ($$ = $1) << ": " << $3.str(); }

no_id_args
    : no_id_arg
    | idents     "," no_id_arg                                  { ($$ = $1) << ", " << $3.str(); }
    | no_id_args "," arg                                        { ($$ = $1) << ", " << $3.str(); }

types
    : type
    | types "," type

type
    : or_types
    | func_type

func_type
    : ptr_type
    | ptr_type "->" func_type                                   { $$ << "(" << $1.str() << ")->(" << $3.str() << ")"; }

or_types
    : simple_type "|" simple_type                               { $$ << "(" << $1.str() << ") | (" << $3.str() << ")"; }
    | or_types    "|" simple_type                               { ($$ = $1) << " | (" << $3.str() << ")"; }

ptr_type
    : simple_type
    | "[" "]" ptr_type                                          { $$ <<    "[](" << $3.str() << ")"; }
    | array   ptr_type                                          { ($$ = $1) << "(" << $2.str() << ")"; }
    | "^"     ptr_type                                          { $$ <<  "^(" << $2.str() << ")"; }

simple_type
    : "type name"                                               { $$ << $1; }
    | "$" "type name"                                           { $$ << "$" << $2; }
    | "(" types opt_comma ")"                                   { $$ <<   "(" << $2.str() << ")"; }
    | "("                 ")"                                   { $$ <<   "(" <<             ")"; }

idents
    : ident
    | idents "," ident                                          { ($$ = $1) << ", " << $3.str(); }

ident
    : "identifier"                                              { $$ << $1; }

opt_comma
    : %empty
    | ","

%%

// This block is inserted at the bottom of parser.cpp

#include <iomanip>

namespace yy {

static std::vector<print::colored_text>
symbol_kind_name(const yy::Parser::symbol_kind_type &kind, print::color highlight = print::color::bold_red) {
    using namespace print;
    switch (kind) {
        case Parser::symbol_kind::S_RETURN:
        case Parser::symbol_kind::S_STRUCT:
        case Parser::symbol_kind::S_OPERATOR:
            return {
                {"keyword `", color::bold_gray},
                {Parser::symbol_name(kind), highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_INT:
            return {
                {"`", color::bold_gray},
                {Parser::symbol_name(kind), highlight},
                {"` literal", color::bold_gray}
            };
        default:
            break;
    }
    return {
        {"`", color::bold_gray},
        {Parser::symbol_name(kind), highlight},
        {"`", color::bold_gray}
    };
}

static std::vector<print::colored_text>
symbol_type_name(const yy::Parser::symbol_type &tok) {
    using namespace print;
    auto kind = tok.kind();
    switch (kind) {
        case Parser::symbol_kind::S_INT:
            return {
                {"Int literal `", color::bold_gray},
                {std::to_string(tok.value.as<std::uint64_t>()), color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_IDENT:
        case Parser::symbol_kind::S_TYPENAME:
        case Parser::symbol_kind::S_SYMBOL:
            return {
                {Parser::symbol_name(kind), color::bold_gray},
                {" `", color::bold_gray},
                {tok.value.as<std::string>(), color::bold_red},
                {"`", color::bold_gray}
            };
        default:
            break;
    }
    return symbol_kind_name(kind);
}

void
Parser::report_syntax_error(yy::Parser::context const &ctx) const {
    using namespace print;

    auto &loc = ctx.location();
    // auto  tok = ctx.token();
    auto &lah = ctx.lookahead();
    auto  num = ctx.expected_tokens(nullptr, 0);
    auto  exp = std::vector<Parser::symbol_kind_type>(num);
    ctx.expected_tokens(exp.data(), num);

    auto message = Message::error(loc.begin)
                   .with_message("expected ", color::bold_gray);
    std::string sep;
    auto n = static_cast<int>(exp.size());
    for (int i = 0; i < n; i++) {
        message.with_message(sep, color::bold_gray);
        for (auto s : symbol_kind_name(exp[i], color::bold_gray)) {
            message.with_message(s);
        }
        sep = (i < n - 2) ? ", " : " or ";
    }
    message.with_message(", found ", color::bold_gray);
    for (auto s : symbol_type_name(lah)) {
        message.with_message(s);
    }
    message.with_detail(loc, color::bold_red)
           .with_message("unexpected ", color::bold_gray);
    for (auto m : symbol_type_name(lah)) {
        message.with_message(m);
    }
    errors.push_back(message);
    failed = true;
}

void
Parser::error(const location &loc, const std::string &message) {
    using namespace print;
    errors.push_back(
        Message::error(loc.begin)
                .with_message(message, color::bold_gray)
                .with_detail(loc, color::bold_red)
                .with_message(message, color::bold_gray)
    );
}

} // namespace yy
