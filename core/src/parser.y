%require "3.7"
%language "C++"
%locations
%defines
%parse-param {class Scanner &scanner}
%parse-param {std::vector<print::Message> &errors}
%parse-param {std::vector<std::unique_ptr<AST::Expression>> &ast_out}
%parse-param {bool &failed}

%define api.namespace {yy}
%define api.parser.class {Parser}
%define api.token.constructor
%define api.value.type variant
%define api.value.automove
%define parse.assert
%define parse.trace
%define parse.error custom
%define parse.lac full
%define api.token.prefix {TOK_}

%code requires {
// This block is inserted at the top of parser.hpp

// Disable compiler-specific warnings for code generated by Bison
#if defined(__clang__)
#    pragma clang diagnostic push
#elif defined(__GNUC__) || defined(__GNUG__)
#    pragma GCC diagnostic push
#elif defined(_MSC_VER)
#    pragma warning(push)
#    pragma warning(disable:                                                                                           \
         4065 /* switch statement contains 'default' but no 'case' labels */                                           \
     )
#endif

#include <optional>

#include "ast/ast_includes.hpp"
#include "printer.hpp"

} // %code requires

%code provides {
// This block is inserted at the bottom of parser.hpp

#if defined(__clang__)
#    pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#    pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#    pragma warning(pop)
#endif

} // %code provides

%{
// This block is inserted at the top of parser.cpp

// Disable compiler-specific warnings for code generated by Bison
#if defined(__clang__)
#elif defined(__GNUC__) || defined(__GNUG__)
#elif defined(_MSC_VER)
#    pragma warning(disable:                                                                                           \
         4065 /* switch statement contains 'default' but no 'case' labels */                                           \
         4127 /* conditional expression is constant */                                                                 \
         4244 /* 'return': conversion from 'std::streamsize' to 'int', possible loss of data */                        \
     )
#endif

#include "scanner.hpp"

#define yylex scanner.scan

#define NODE(type, ...) std::make_unique<AST:: type>(__VA_ARGS__)

%}

%initial-action {
    // Invoked before parsing each time parse() is called.
}

/* TOKENS */
%token
    EOF 0       "end of file"
    RETURN      "return"
    LPAREN      "("
    RPAREN      ")"
    LBRACE      "{"
    RBRACE      "}"
    LBRACKET    "["
    RBRACKET    "]"
    BRACKETS    "[]"
    SEMICOLON   ";"
    TYPE_DECL   ":"
    DEFINE      ":="
    CONSTDEF    "::"
    ASSIGN      "="
    COMMA       ","
    DOT         "."
    TICK        "'"
    ARROW       "->"
    BIGARROW    "=>"
    DOLLAR      "$"
    MUL         "*"
    DIV         "/"
    MOD         "%"
    PLUS        "+"
    MINUS       "-"
    LSHIFT      "<<"
    RSHIFT      ">>"
    LT          "<"
    LE          "<="
    GT          ">"
    GE          ">="
    EQ          "=="
    NE          "!="
    BITAND      "&"
    BITXOR      "^"
    BITOR       "|"
    AND         "&&"
    OR          "||"

%token< uint64_t >
    U64         "`U64` literal"

%token< std::string >
    IDENT       "identifier"
    TYPENAME    "type name"
    OPERATOR    "operator"

%type< std::stringstream >
    opt_lines
    lines
    line
    expressions
    opt_expression
    expression
    op_expr
    operand
    block_expr
    apply_expr
    simple_expr
    no_paren_simple_expr
    paren_simple_expr
    block
    tuple
    no_id_expr
    func_expr
    func_sig
    no_id_args
    no_id_exprs
    no_id_arg
    arg
    type
    no_unit_types
    no_unit_type
    or_type
    or_types
    func_type
    simple_type
    ident_array
    idents
    ident
    units
    unit
    unit_tuple

%left "||"
%left "&&"
%left "|"
%left "^"
%left "&"
%left "==" "!="
%left "<" "<=" ">" ">="
%left "<<" ">>"
%left "+" "-"
%left "*" "/" "%"
%left "operator" "'"
%precedence UNARY

%start file

%%

file
    : opt_lines                                                 { std::cout << $1.str(); }

opt_lines
    : %empty {}
    | lines

lines
    : line
    | lines line                                                { $$ = $1 << $2.str(); }

line
    : expression ";"                                            { $$ = $1 << ";\n"; }
    | "return" expression ";"                                   { $$ << "return (" << $2.str() << ");\n"; }
    | error ";"                                                 { $$ << "<ERROR>;\n"; yyerrok; }

expressions
    : expression
    | error                                                     { $$ << "<ERROR>"; yyerrok; }
    | expressions "," expression                                { $$ = $1 << ", " << $3.str(); }
    | expressions "," error                                     { $$ = $1 << ", " << "<ERROR>"; yyerrok; }

opt_expression
    : %empty {}
    | expression

expression
    : no_id_expr
    | ident
    | unit

no_id_expr
    : apply_expr
    | block_expr
    | op_expr
    | func_expr
    | ident ":=" expression                                     { $$ = $1 << " := (" << $3.str() << ")"; }
    | ident "::" expression                                     { $$ = $1 << " :: (" << $3.str() << ")"; }
    | ident ":" type "=" expression                             { $$ = $1 << ": (" << $3.str() << ") = (" << $5.str() << ")"; }

block_expr
    : block
    | type block                                                { $$ << "(" << $1.str() << ")" << $2.str(); }

func_expr
    : func_sig expression                                       { $$ = $1 << "(" << $2.str() << ")"; }

func_sig
    : "(" no_id_args opt_comma ")" "=>"                         { $$ << "(" << $2.str() << ") => "; }
    | "(" idents     opt_comma ")" "=>"                         { $$ << "(" << $2.str() << ") => "; }
    | "(" ")"                      "=>"                         { $$ << "(" <<             ") => "; }
    | ident                        "=>"                         { $$ << "(" << $1.str() << ") => "; }
    | ident ":" type               "=>"                         { $$ << "(" << $1.str() << ": " << $3.str() << ") => "; }

op_expr
    : operand "*"  operand                                      { $$ << "(" << $1.str() << ") * ("  << $3.str() << ")"; }
    | operand "/"  operand                                      { $$ << "(" << $1.str() << ") / ("  << $3.str() << ")"; }
    | operand "%"  operand                                      { $$ << "(" << $1.str() << ") % ("  << $3.str() << ")"; }
    | operand "+"  operand                                      { $$ << "(" << $1.str() << ") + ("  << $3.str() << ")"; }
    | operand "-"  operand                                      { $$ << "(" << $1.str() << ") - ("  << $3.str() << ")"; }
    | operand "<<" operand                                      { $$ << "(" << $1.str() << ") << (" << $3.str() << ")"; }
    | operand ">>" operand                                      { $$ << "(" << $1.str() << ") >> (" << $3.str() << ")"; }
    | operand "<"  operand                                      { $$ << "(" << $1.str() << ") < ("  << $3.str() << ")"; }
    | operand "<=" operand                                      { $$ << "(" << $1.str() << ") <= (" << $3.str() << ")"; }
    | operand ">"  operand                                      { $$ << "(" << $1.str() << ") > ("  << $3.str() << ")"; }
    | operand ">=" operand                                      { $$ << "(" << $1.str() << ") >= (" << $3.str() << ")"; }
    | operand "==" operand                                      { $$ << "(" << $1.str() << ") == (" << $3.str() << ")"; }
    | operand "!=" operand                                      { $$ << "(" << $1.str() << ") != (" << $3.str() << ")"; }
    | operand "&"  operand                                      { $$ << "(" << $1.str() << ") & ("  << $3.str() << ")"; }
    | operand "^"  operand                                      { $$ << "(" << $1.str() << ") ^ ("  << $3.str() << ")"; }
    | operand "|"  operand                                      { $$ << "(" << $1.str() << ") | ("  << $3.str() << ")"; }
    | operand "&&" operand                                      { $$ << "(" << $1.str() << ") && (" << $3.str() << ")"; }
    | operand "||" operand                                      { $$ << "(" << $1.str() << ") || (" << $3.str() << ")"; }
    | operand "operator"    operand                             { $$ << "(" << $1.str() << ") "  << $2       << " ("  << $3.str() << ")"; }
    | operand "'" ident operand                                 { $$ << "(" << $1.str() << ") '" << $3.str() << " (" << $4.str() << ")"; }
    | "+" operand        %prec UNARY                            { $$ << "+("      << $2.str() << ")"; }
    | "-" operand        %prec UNARY                            { $$ << "-("      << $2.str() << ")"; }
    | "operator" operand %prec UNARY                            { $$ << $1 << "(" << $2.str() << ")"; }

operand
    : op_expr
    | apply_expr
    | ident
    | unit

apply_expr
    : simple_expr
    | ident      no_paren_simple_expr                           { $$ << "(" << $1.str() << ")<-(" << $2.str() << ")"; }
    | ident      ident                                          { $$ << "(" << $1.str() << ")<-(" << $2.str() << ")"; }
    | unit       no_paren_simple_expr                           { $$ = $1 <<                "<-(" << $2.str() << ")"; }
    | unit       ident                                          { $$ = $1 <<                "<-(" << $2.str() << ")"; }
    | apply_expr no_paren_simple_expr                           { $$ << "(" << $1.str() << ")<-(" << $2.str() << ")"; }
    | apply_expr ident                                          { $$ << "(" << $1.str() << ")<-(" << $2.str() << ")"; }

simple_expr
    : no_paren_simple_expr
    | paren_simple_expr

no_paren_simple_expr
    : no_paren_simple_expr "." ident                            { $$ << "(" << $1.str() << ")." << $3.str(); }
    | ident                "." ident                            { $$ << "(" << $1.str() << ")." << $3.str(); }
    | no_paren_simple_expr tuple                                { $$ << "(" << $1.str() << ")<-" << $2.str(); }
    | ident                tuple                                { $$ << "(" << $1.str() << ")<-" << $2.str(); }
    | no_paren_simple_expr unit                                 { $$ << "(" << $1.str() << ")<-" << $2.str(); }
    | ident                unit                                 { $$ << "(" << $1.str() << ")<-" << $2.str(); }
    | no_paren_simple_expr "[" expressions "]"                  { $$ << "(" << $1.str() << ")[" << $3.str() << ",]"; }
    | ident                "[" expressions "]"                  { $$ << "(" << $1.str() << ")[" << $3.str() << ",]"; }
    | U64                                                       { $$ << $1; }

paren_simple_expr
    : tuple
    | "[" no_id_exprs "]"                                       { $$ << "[" << $2.str() << ",]"; }
    | ident_array
    | paren_simple_expr "." ident                               { $$ = $1 << "." << $3.str(); }
    | paren_simple_expr tuple                                   { $$ = $1 << "<-" << $2.str(); }
    | paren_simple_expr unit                                    { $$ = $1 << "<-" << $2.str(); }
    | unit              "." ident                               { $$ = $1 << "." << $3.str(); }
    | unit              tuple                                   { $$ = $1 << "<-" << $2.str(); }
    | unit              unit                                    { $$ = $1 << "<-" << $2.str(); }
    | paren_simple_expr "[" expressions "]"                     { $$ = $1 << "[" << $3.str() << ",]"; }
    | unit              "[" expressions "]"                     { $$ = $1 << "[" << $3.str() << ",]"; }

tuple
    : "(" no_id_exprs opt_comma ")"                             { $$ << "(" << $2.str() << ",)"; }
    | "(" idents      opt_comma ")"                             { $$ << "(" << $2.str() << ",)"; }

no_id_exprs
    : no_id_expr
    | idents      "," no_id_expr                                { $$ = $1 << ", " << $3.str(); }
    | idents      "," unit                                      { $$ = $1 << ", " << $3.str(); }
    | units       "," no_id_expr                                { $$ = $1 << ", " << $3.str(); }
    | units       "," ident                                     { $$ = $1 << ", " << $3.str(); }
    | no_id_exprs "," expression                                { $$ = $1 << ", " << $3.str(); }

block
    : "{" opt_expression "}"                                    { $$ << "{" << $2.str() << "}"; }
    | "{" lines opt_expression "}"                              { $$ << "{" << $2.str() << $3.str() << "}"; }

arg
    : no_id_arg
    | ident

no_id_arg
    : ident ":" type                                            { $$ = $1 << ": " << $3.str(); }

no_id_args
    : no_id_arg
    | idents     "," no_id_arg                                  { $$ = $1 << ", " << $3.str(); }
    | no_id_args "," arg                                        { $$ = $1 << ", " << $3.str(); }

type
    : no_unit_type
    | unit

no_unit_type
    : or_type
    | func_type

func_type
    : simple_type "->" simple_type                              { $$ << "(" << $1.str() << ")->(" << $3.str() << ")"; }
    | simple_type "->" unit                                     { $$ << "(" << $1.str() << ")->"  << $3.str(); }
    | unit        "->" simple_type                              { $$ = $1 <<                "->(" << $3.str() << ")"; }
    | unit        "->" unit                                     { $$ = $1 <<                "->"  << $3.str(); }
    | simple_type "->" func_type                                { $$ << "(" << $1.str() << ")->(" << $3.str() << ")"; }
    | unit        "->" func_type                                { $$ = $1 <<                "->"  << $3.str(); }

or_type
    : simple_type
    | or_types

or_types
    : simple_type "|" simple_type                               { $$ << "(" << $1.str() << ") | (" << $3.str() << ")"; }
    | or_types    "|" simple_type                               { $$ = $1 << " | (" << $3.str() << ")"; }

simple_type
    : "type name"                                               { $$ << $1; }
    | "$" "type name"                                           { $$ << "$" << $2; }
    | simple_type "[]"                                          { $$ << "(" << $1.str() << ")[]"; }
    | unit        "[]"                                          { $$        << $1.str()  << "[]"; }
    | "(" no_unit_types opt_comma ")"                           { $$ << "(" << $2.str() << ",)"; }

no_unit_types
    : no_unit_type
    | units         "," no_unit_type                            { $$ = $1 << ", " << $3.str(); }
    | no_unit_types "," type                                    { $$ = $1 << ", " << $3.str(); }

ident_array
    : "[" idents opt_comma "]"                                  { $$ << "[" << $2.str() << ",]"; }

idents
    : ident
    | idents "," ident                                          { $$ = $1 << ", " << $3.str(); }

ident
    : "identifier"                                              { $$ << $1; }

units
    : unit
    | units "," unit                                            { $$ = $1 << ", " << $3.str(); }

unit_tuple
    : "(" units opt_comma ")"                                   { $$ << "(" << $2.str() << ",)"; }

unit
    : unit_tuple
    | "(" ")"                                                   { $$ << "()"; }


opt_comma
    : %empty
    | ","

%%

// This block is inserted at the bottom of parser.cpp

#include <iomanip>

namespace yy {

static std::vector<print::colored_text>
symbol_kind_name(const yy::Parser::symbol_kind_type &kind, print::color highlight = print::color::bold_red) {
    using namespace print;
    switch (kind) {
        case Parser::symbol_kind::S_LPAREN:
            return {
                {"`", color::bold_gray},
                {"(", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_RPAREN:
            return {
                {"`", color::bold_gray},
                {")", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_LBRACE:
            return {
                {"`", color::bold_gray},
                {"{", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_RBRACE:
            return {
                {"`", color::bold_gray},
                {"}", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_LBRACKET:
            return {
                {"`", color::bold_gray},
                {"[", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_RBRACKET:
            return {
                {"`", color::bold_gray},
                {"]", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_SEMICOLON:
            return {
                {"`", color::bold_gray},
                {";", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_TYPE_DECL:
            return {
                {"`", color::bold_gray},
                {":", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_DEFINE:
            return {
                {"`", color::bold_gray},
                {":=", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_CONSTDEF:
            return {
                {"`", color::bold_gray},
                {"::", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_ASSIGN:
            return {
                {"`", color::bold_gray},
                {"=", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_COMMA:
            return {
                {"`", color::bold_gray},
                {",", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_DOT:
            return {
                {"`", color::bold_gray},
                {".", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_ARROW:
            return {
                {"`", color::bold_gray},
                {"->", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_BIGARROW:
            return {
                {"`", color::bold_gray},
                {"=>", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_MUL:
            return {
                {"`", color::bold_gray},
                {"*", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_DIV:
            return {
                {"`", color::bold_gray},
                {"/", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_MOD:
            return {
                {"`", color::bold_gray},
                {"%", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_PLUS:
            return {
                {"`", color::bold_gray},
                {"+", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_MINUS:
            return {
                {"`", color::bold_gray},
                {"-", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_LSHIFT:
            return {
                {"`", color::bold_gray},
                {"<<", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_RSHIFT:
            return {
                {"`", color::bold_gray},
                {">>", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_LT:
            return {
                {"`", color::bold_gray},
                {"<", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_LE:
            return {
                {"`", color::bold_gray},
                {"<=", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_GT:
            return {
                {"`", color::bold_gray},
                {">", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_GE:
            return {
                {"`", color::bold_gray},
                {">=", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_EQ:
            return {
                {"`", color::bold_gray},
                {"==", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_NE:
            return {
                {"`", color::bold_gray},
                {"!=", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_BITAND:
            return {
                {"`", color::bold_gray},
                {"&", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_BITXOR:
            return {
                {"`", color::bold_gray},
                {"^", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_BITOR:
            return {
                {"`", color::bold_gray},
                {"|", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_AND:
            return {
                {"`", color::bold_gray},
                {"&&", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_OR:
            return {
                {"`", color::bold_gray},
                {"||", highlight},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_OPERATOR:
            return {{"operator", highlight}};
        case Parser::symbol_kind::S_U64:
            return {{"int literal", highlight}};
        case Parser::symbol_kind::S_IDENT:
            return {{"identifier", highlight}};
        case Parser::symbol_kind::S_TYPENAME:
            return {{"type name", highlight}};
        default:
            break;
    }
    return {{yy::Parser::symbol_name(kind), highlight}};
}

static std::vector<print::colored_text>
symbol_type_name(const yy::Parser::symbol_type &tok) {
    using namespace print;
    auto kind = tok.kind();
    switch (kind) {
        case Parser::symbol_kind::S_U64:
            return {
                {"`U64` literal `", color::bold_gray},
                {std::to_string(tok.value.as<std::uint64_t>()), color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_IDENT:
            return {
                {"identifier `", color::bold_gray},
                {tok.value.as<std::string>(), color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_TYPENAME:
            return {
                {"type name `", color::bold_gray},
                {tok.value.as<std::string>(), color::bold_red},
                {"`", color::bold_gray}
            };
        case Parser::symbol_kind::S_OPERATOR:
            return {
                {"operator `", color::bold_gray},
                {tok.value.as<std::string>(), color::bold_red},
                {"`", color::bold_gray}
            };
        default:
            break;
    }
    return symbol_kind_name(kind);
}

void
Parser::report_syntax_error(yy::Parser::context const &ctx) const {
    using namespace print;

    auto &loc = ctx.location();
    // auto  tok = ctx.token();
    auto &lah = ctx.lookahead();
    auto  num = ctx.expected_tokens(nullptr, 0);
    auto  exp = std::vector<Parser::symbol_kind_type>(num);
    ctx.expected_tokens(exp.data(), num);

    auto message = Message::error(loc.begin)
                   .with_message("expected ", color::bold_gray);
    std::string sep;
    auto n = static_cast<int>(exp.size());
    for (int i = 0; i < n; i++) {
        message.with_message(sep, color::bold_gray);
        for (auto s : symbol_kind_name(exp[i], color::bold_gray)) {
            message.with_message(s);
        }
        sep = (i < n - 2) ? ", " : " or ";
    }
    message.with_message(", found ", color::bold_gray);
    for (auto s : symbol_type_name(lah)) {
        message.with_message(s);
    }
    message.with_detail(loc, color::bold_red)
           .with_message("unexpected ", color::bold_gray);
    for (auto m : symbol_type_name(lah)) {
        message.with_message(m);
    }
    errors.push_back(message);
    failed = true;
}

void
Parser::error(const location &loc, const std::string &message) {
    using namespace print;
    errors.push_back(
        Message::error(loc.begin)
                .with_message(message, color::bold_gray)
                .with_detail(loc, color::bold_red)
                .with_message(message, color::bold_gray)
    );
}

} // namespace yy
