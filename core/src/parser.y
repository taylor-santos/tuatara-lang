%require "3.7"
%language "C++"
%locations
%defines
%parse-param {class Scanner &scanner}
%parse-param {std::ostream &output}
%parse-param {std::vector<std::unique_ptr<AST::Expression>> &ast_out}
%parse-param {bool &parse_failure}

%define api.namespace {yy}
%define api.parser.class {Parser}
%define api.token.constructor
%define api.value.type variant
%define api.value.automove
%define parse.assert
%define parse.trace
%define parse.error verbose
%define parse.lac full
%define api.token.prefix {TOK_}

%code requires {
// This block is inserted at the top of parser.hpp

// Disable compiler-specific warnings for code generated by Bison
#if defined(__clang__)
#    pragma clang diagnostic push
#elif defined(__GNUC__) || defined(__GNUG__)
#    pragma GCC diagnostic push
#elif defined(_MSC_VER)
#    pragma warning(push)
#    pragma warning(disable:                                                                                           \
         4065 /* switch statement contains 'default' but no 'case' labels */                                           \
     )
#endif

#include <variant>

#include "ast/ast_includes.hpp"

using int_variant = std::variant<uint64_t, int64_t, uint32_t, int32_t, uint16_t, int16_t, uint8_t, int8_t>;

static int_variant
parse_int(std::string str);

template<typename T>
std::string
int_out_of_range(std::string val, int base = 10);

template<bool negate, typename T>
std::string
int_out_of_range(T val, int base = 10);

} // %code requires

%code provides {
// This block is inserted at the bottom of parser.hpp

#if defined(__clang__)
#    pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#    pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#    pragma warning(pop)
#endif

} // %code provides

%{
// This block is inserted at the top of parser.cpp

// Disable compiler-specific warnings for code generated by Bison
#if defined(__clang__)
#elif defined(__GNUC__) || defined(__GNUG__)
#elif defined(_MSC_VER)
#    pragma warning(disable:                                                                                           \
         4065 /* switch statement contains 'default' but no 'case' labels */                                           \
         4127 /* conditional expression is constant */                                                                 \
         4244 /* 'return': conversion from 'std::streamsize' to 'int', possible loss of data */                        \
     )
#endif

#include <climits>
#include <bitset>

#include "scanner.hpp"

#define yylex scanner.scan

#define NODE(type, ...) std::make_unique<AST:: type>(__VA_ARGS__)

template <bool negate>
std::unique_ptr<AST::Literal>
make_signed(int_variant &&var, yy::location loc);

template<typename T>
std::string
int_out_of_range(std::string val, int base);

template<bool negate, typename T>
std::string
int_out_of_range(T val, int base);

%}

%initial-action {
    // Invoked before parsing each time parse() is called.
    parse_failure = false;
}

/* TOKENS */
%token
    EOF 0       "end of file"
    SEMICOLON   ";"
    TYPE_DECL   "::"
    DEFINE      ":="
    PLUS        "+"
    MINUS       "-"

%token<std::string>
    IDENT       "identifier"
    TYPENAME    "type name"
    INT         "int literal"

%type<std::vector<std::unique_ptr<AST::Expression>>>
    expressions

%type<std::unique_ptr<AST::Expression>>
    expression

%type<std::unique_ptr<AST::Definition>>
    definition

%type<std::unique_ptr<AST::SimpleExpression>>
    simple_expression

%type<std::unique_ptr<AST::Literal>>
    literal

%type<std::unique_ptr<AST::Type>>
    type

%type<std::string>
    unary_int

%start file

%%

file
    : %empty {
        ast_out.clear();
    }
    | expressions {
        ast_out = $1;
        if (parse_failure) YYABORT;
    }

expressions
    : expression ";" {
        $$.emplace_back($1);
    }
    | expressions expression ";" {
        $$ = $1;
        $$.emplace_back($2);
    }

expression
    : definition {
        $$ = $1;
    }
    | simple_expression {
        $$ = $1;
    }

definition
    : "identifier" ":=" expression {
        $$ = NODE(ValueDefinition, $1, @1, $3, @$);
    }
    | "identifier" "::" type {
        $$ = NODE(TypeDefinition, $1, @1, $3, @$);
    }

simple_expression
    : literal {
        $$ = $1;
    }
    | "identifier" {
        $$ = NODE(Variable, $1, @$);
    }
    | error {
        $$ = NODE(Error, @$);
    }

literal
    : unary_int {
        std::visit(
            [&](auto &&val) {
                using T = std::decay_t<decltype(val)>;
                $$ = NODE(Int<T>, val, @$);
            },
            parse_int($1)
        );
    }

unary_int
    : "int literal"
    | "+" "int literal" {
        $$ = "+" + $2;
    }
    | "-" "int literal" {
        $$ = "-" + $2;
    }

type
    : "type name" {
        $$ = NODE(ObjectType, $1, @1, @$);
    }
    | error {
        $$ = NODE(Error, @$);
    }

%%

// This block is inserted at the bottom of parser.cpp

namespace yy {

void
Parser::error(const location &loc, const std::string &message) {
    if (loc.begin.filename) output << "" << *loc.begin.filename << ":";
    output << loc.begin.line << ":" << loc.begin.column << " " << message << std::endl;
    parse_failure = true;
}

}

static int_variant
parse_int(std::string str) {
    str.erase(remove(str.begin(), str.end(), '_'), str.end());
    std::string type;
    auto end = str.find_first_of("uUiI");
    if (end != std::string::npos) {
        type = str.substr(end);
        str  = str.substr(0, end);
    }
    if (type == "" || type[0] == 'u' || type[0] == 'U') {
        auto val =
    }

    return 123;
}

template <bool negate>
std::unique_ptr<AST::Literal>
make_signed(int_variant &&var, yy::location loc) {
    return std::visit([&](auto &&val) -> std::unique_ptr<AST::Literal> {
        using T = std::decay_t<decltype(val)>;
        if constexpr (std::is_signed_v<T>) {
            if constexpr (negate) {
                static_assert(std::numeric_limits<T>::min() + 1 == -std::numeric_limits<T>::max());
                if (val == std::numeric_limits<T>::min()) {
                    throw yy::Parser::syntax_error(loc, int_out_of_range<negate>(val, 10));
                }
                val = -val;
            }
            return std::make_unique<AST::Int<T>>(val, loc);
        } else { // Unsigned
            using S = typename std::make_signed<T>::type;
            S sval = val;
            T max  = std::numeric_limits<S>::max();
            if constexpr (negate) {
                max++;
                sval = (~sval) + 1;
            }
            if (val > max) {
                throw yy::Parser::syntax_error(loc, int_out_of_range<negate>(val, 10));
            }
            return std::make_unique<AST::Int<S>>(sval, loc);
        }
    }, var);
}

template<typename T>
std::string
int_out_of_range(std::string val, int base) {
    constexpr size_t sz = sizeof(T)*CHAR_BIT;
    std::stringstream ss;
    ss << "syntax error, " << val << " out of range of " << AST::Int<T>::type_name << " (";
    switch (base) {
        case 2:
            ss << "0b" << std::bitset<sz>(std::numeric_limits<T>::min()) << " to "
               << "0b" << std::bitset<sz>(std::numeric_limits<T>::max());
            break;
        case 8:
            ss << "0o" << std::oct << std::numeric_limits<T>::min() << " to "
               << "0o" << std::oct << std::numeric_limits<T>::max();
            break;
        case 16:
            ss << "0x" << std::hex << std::numeric_limits<T>::min() << " to "
               << "0x" << std::hex << std::numeric_limits<T>::max();
            break;
        default:
            if constexpr (std::is_signed_v<T>) {
                ss << static_cast<int64_t>(std::numeric_limits<T>::min()) << " to "
                   << static_cast<int64_t>(std::numeric_limits<T>::max());
            } else {
                ss << static_cast<uint64_t>(std::numeric_limits<T>::min()) << " to "
                   << static_cast<uint64_t>(std::numeric_limits<T>::max());
            }
    }
    ss << ")";
    return ss.str();
}

template<bool negate, typename T>
std::string
int_out_of_range(T val, int base) {
    std::stringstream ss;
    ss << (negate ? "-" : "");
    if constexpr (std::is_signed_v<T>) {
        ss << static_cast<int64_t>(val);
    } else {
        ss << static_cast<uint64_t>(val);
    }
    return int_out_of_range<T>(ss.str(), base);
}
