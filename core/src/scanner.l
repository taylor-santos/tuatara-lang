%option debug
%option c++
%option noyywrap
%option never-interactive
%option nounput
%option batch
%option prefix="yy"
%option stack
%option nodefault
%option warn
%option nounistd
%option yyclass="Scanner"

/* Declare perf-report twice to enable minor performance loss reporting */
%option perf-report perf-report
%option verbose

%top{
// This block is inserted at the top of scanner.cpp

// Disable compiler-specific warnings for code generated by Flex
#if defined(__clang__)
#elif defined(__GNUC__) || defined(__GNUG__)
#elif defined(_MSC_VER)
#    include <stdint.h> // Prevent a ton of warning C4005: macro redefinition
#    pragma warning(disable:                                                                                           \
         4244 /* 'return': conversion from 'std::streamsize' to 'int', possible loss of data */                        \
     )
#endif

#include <sstream>
#include <iomanip>
#include <algorithm>

}

%{
// This block is inserted in the definitions section of scanner.cpp

#include "scanner.hpp"

class yyFlexLexer;

#define LINE() {                                                                                                       \
    loc.lines(1);                                                                                                      \
}

#define YY_USER_ACTION {                                                                                               \
    loc_.step();                                                                                                        \
    loc_.columns(yyleng);                                                                                               \
}

%}

ident_start    [a-z]
typename_start [A-Z]
ident          [_0-9a-zA-Z]

%%

%{
    // This block is executed every time yylex() is called.
%}

[[:digit:]]([_]*[[:digit:]]+)* {
    try {
        auto text = std::string(yytext);
        text.erase(remove(text.begin(), text.end(), '_'), text.end());
        auto ull = std::stoull(text, nullptr, 10);
        if (ull > std::numeric_limits<uint64_t>::max()) {
            // The c++ standard only guarantees that unsigned long long has *at least* 64 bits of precision.
            // Make sure that the conversion to uint64_t will not overflow.
            throw std::out_of_range("");
        }
        auto u64 = static_cast<uint64_t>(ull);
        return yy::Parser::make_U64(u64, loc_);
    } catch (const std::exception &) {
        std::stringstream ss;
        ss << "syntax error, " << yytext << " out of range of u64";
        throw yy::Parser::syntax_error(loc_, ss.str());
    }
}

{ident_start}{ident}*    { return yy::Parser::make_IDENT(yytext, loc_); }
{typename_start}{ident}* { return yy::Parser::make_TYPENAME(yytext, loc_); }

[[:blank:]\n\r]+ // Ignore whitespace
. {
    std::stringstream msg;
    msg << "stray '";
    if (*yytext >= 0 && std::isprint(*yytext)) {
        msg << *yytext;
    } else {
        // We want to print the character (which is a signed char) as its octal value.
        // Casting directly to unsigned int incorrectly handles negative values:
        // For example, (char)-1 == 0xff == 255, but (unsigned int)-1 == 0xffffffff == 4294967295.
        // By first casting char to unsigned char, the number of set bits is preserved but the sign is changed.
        // Just casting to uint8_t also doesn't work, because the stringstream just treats it as char
        msg << '\\' << std::setfill('0') << std::setw(3) << std::right << std::oct;
        msg << static_cast<int>(static_cast<unsigned char>(*yytext));
    }
    msg << "' in program";
    throw yy::Parser::syntax_error(loc_, msg.str());
}
<<EOF>> {
    return yy::Parser::make_EOF(loc_);
}

%%

// This block is inserted at the bottom of scanner.cpp

namespace yy {

Scanner::Scanner(std::string path, std::istream &input, std::ostream &output)
    : yyFlexLexer()
    , path_{std::move(path)}
    , input_{input}
    , output_{output} {
    loc_.initialize(&path_);
    switch_streams(input_, output_);
}

Scanner::~Scanner() = default;

void
Scanner::set_debug_level(int l) {
    yy_flex_debug = l;
}

void
Scanner::error(const location &loc, const std::string &message) const {
    if (loc.begin.filename) output_ << "" << *loc.begin.filename << ":";
    output_ << loc.begin.line << ":" << loc.begin.column << " " << message << std::endl;
}

} // namespace yy
