%option debug
%option c++
%option noyywrap
%option never-interactive
%option nounput
%option batch
%option prefix="yy"
%option stack
%option nodefault
%option warn
%option nounistd
%option yyclass="Scanner"

/* Declare perf-report twice to enable minor performance loss reporting */
%option perf-report perf-report
%option verbose

%top{
// This block is inserted at the top of scanner.cpp

// Disable compiler-specific warnings for code generated by Flex
#if defined(__clang__)
#elif defined(__GNUC__) || defined(__GNUG__)
#elif defined(_MSC_VER)
#    include <stdint.h> // Prevent a ton of warning C4005: macro redefinition
#    pragma warning(disable:                                                                                           \
         4244 /* 'return': conversion from 'std::streamsize' to 'int', possible loss of data */                        \
     )
#endif

#include <sstream>
#include <iomanip>
#include <algorithm>

}

%{
// This block is inserted in the definitions section of scanner.cpp

#include "scanner.hpp"

class yyFlexLexer;

#define LINE() {                                                                                                       \
    loc.lines(1);                                                                                                      \
}

#define YY_USER_ACTION {                                                                                               \
    loc_.step();                                                                                                        \
    loc_.columns(yyleng);                                                                                               \
}

static yy::Parser::symbol_type
lex_int(const char *yytext, yy::location loc);

static void
throw_unrecognized_char(char c, yy::location loc);

%}

ident_start    [a-z]
typename_start [A-Z]
ident          [_0-9a-zA-Z]

%%

%{
    // This block is executed every time yylex() is called.
%}

[\r]?[\n]?      { loc_.lines(1); }
[[:blank:]]+    { /* Ignore whitespace */ }

[[:digit:]]([_]*[[:digit:]]+)*  { return lex_int(yytext, loc_); }

{ident_start}{ident}*       { return yy::Parser::make_IDENT(yytext, loc_); }
{typename_start}{ident}*    { return yy::Parser::make_TYPENAME(yytext, loc_); }

;   { return yy::Parser::make_SEMICOLON(loc_); }
::  { return yy::Parser::make_TYPE_DECL(loc_); }
:=  { return yy::Parser::make_DEFINE(loc_); }

.       { throw_unrecognized_char(*yytext, loc_); }
<<EOF>> { return yy::Parser::make_EOF(loc_); }

%%

// This block is inserted at the bottom of scanner.cpp

static yy::Parser::symbol_type
lex_int(const char *yytext, yy::location loc) {
    try {
        auto text = std::string(yytext);
        text.erase(remove(text.begin(), text.end(), '_'), text.end());
        auto ull = std::stoull(text, nullptr, 10);
        if (ull <= std::numeric_limits<uint64_t>::max()) {
            // The c++ standard only guarantees that unsigned long long has *at least* 64 bits of precision.
            // Make sure that the conversion to uint64_t will not overflow.
            auto u64 = static_cast<uint64_t>(ull);
            return yy::Parser::make_U64(u64, loc);
        }
    } catch (...) {}
    std::stringstream ss;
    ss << "syntax error, " << yytext << " out of range of u64";
    throw yy::Parser::syntax_error(loc, ss.str());
}

static void
throw_unrecognized_char(char c, yy::location loc) {
    std::stringstream msg;
        msg << "stray '";
        if (c >= 0 && std::isprint(c)) {
            msg << c;
        } else {
            // We want to print the character (which is a signed char) as its octal value.
            // Casting directly to unsigned int incorrectly handles negative values:
            // For example, (char)-1 == 0xff == 255, but (unsigned int)-1 == 0xffffffff == 4294967295.
            // By first casting char to unsigned char, the number of set bits is preserved but the sign is changed.
            // Just casting to uint8_t also doesn't work, because the stringstream just treats it as char
            msg << '\\' << std::setfill('0') << std::setw(3) << std::right << std::oct;
            msg << static_cast<int>(static_cast<unsigned char>(c));
        }
        msg << "' in program";
        throw yy::Parser::syntax_error(loc, msg.str());
}

namespace yy {

Scanner::Scanner(std::string path, std::istream &input)
    : yyFlexLexer()
    , path_{std::move(path)}
    , input_{input} {
    loc_.initialize(&path_);
    switch_streams(&input_);
}

Scanner::~Scanner() = default;

void
Scanner::set_debug_level(int l) {
    yy_flex_debug = l;
}

} // namespace yy
