%option debug
%option c++
%option noyywrap
%option never-interactive
%option nounput
%option batch
%option prefix="yy"
%option stack
%option nodefault
%option warn
%option nounistd
%option yyclass="Scanner"

/* Declare perf-report twice to enable minor performance loss reporting */
%option perf-report perf-report
%option verbose

%top{
// This block is inserted at the top of scanner.cpp

// Disable compiler-specific warnings for code generated by Flex
#if defined(__clang__)
#elif defined(__GNUC__) || defined(__GNUG__)
#elif defined(_MSC_VER)
#    include <stdint.h> // Prevent a ton of warning C4005: macro redefinition
#    pragma warning(disable:                                                                                           \
         4244 /* 'return': conversion from 'std::streamsize' to 'int', possible loss of data */                        \
     )
#endif

}

%{
// This block is inserted in the definitions section of scanner.cpp

#include <sstream>
#include <iomanip>
#include <algorithm>

#include "scanner.hpp"
#include "str_to_int.hpp"

#define LINE() {                                                                                                       \
    loc.lines(1);                                                                                                      \
}

#define YY_USER_ACTION {                                                                                               \
    loc_.step();                                                                                                       \
    loc_.columns(yyleng);                                                                                              \
}

static std::string
unrecognized_char(char c);

template<typename T>
static yy::Parser::symbol_type
lex_int(const char *text, yy::location loc);

%}

ident_start     [a-z]
typename_start  [A-Z]
ident           [_0-9a-zA-Z]
dec_int         0[dD][0-9_]*[0-9]|[0-9]([0-9_]*[0-9])?
hex_int         0[xX][0-9a-fA-F_]*[0-9a-fA-F]
oct_int         0[oO][0-7_]*[0-7]
bin_int         0[bB][01_]*[01]
int_suffix      (_?[iIuU](8|16|32|64))

%%

%{
    // This block is executed every time yylex() is called.
%}

[\r]?[\n]?      { loc_.lines(1); }
[[:blank:]]+    { /* Ignore whitespace */ }

({bin_int}|{oct_int}|{dec_int}|{hex_int})(_?u64)?    { return lex_int<uint64_t>(yytext, loc_); }
({bin_int}|{oct_int}|{dec_int}|{hex_int})_?i64       { return lex_int< int64_t>(yytext, loc_); }
({bin_int}|{oct_int}|{dec_int}|{hex_int})_?u32       { return lex_int<uint32_t>(yytext, loc_); }
({bin_int}|{oct_int}|{dec_int}|{hex_int})_?i32       { return lex_int< int32_t>(yytext, loc_); }
({bin_int}|{oct_int}|{dec_int}|{hex_int})_?u16       { return lex_int<uint16_t>(yytext, loc_); }
({bin_int}|{oct_int}|{dec_int}|{hex_int})_?i16       { return lex_int< int16_t>(yytext, loc_); }
({bin_int}|{oct_int}|{dec_int}|{hex_int})_?u8        { return lex_int<uint8_t >(yytext, loc_); }
({bin_int}|{oct_int}|{dec_int}|{hex_int})_?i8        { return lex_int< int8_t >(yytext, loc_); }

{ident_start}{ident}*       { return yy::Parser::make_IDENT(yytext, loc_); }
{typename_start}{ident}*    { return yy::Parser::make_TYPENAME(yytext, loc_); }

;   { return yy::Parser::make_SEMICOLON(loc_); }
::  { return yy::Parser::make_TYPE_DECL(loc_); }
:=  { return yy::Parser::make_DEFINE(loc_); }

[+] { return yy::Parser::make_PLUS(loc_);  }
[-] { return yy::Parser::make_MINUS(loc_); }

.       { throw yy::Parser::syntax_error(loc_, unrecognized_char(*yytext)); }
<<EOF>> { return yy::Parser::make_EOF(loc_); }

%%

// This block is inserted at the bottom of scanner.cpp

#include "parser.hpp"

static std::string
unrecognized_char(char c) {
    std::stringstream msg;
    msg << "stray '";
    if (c >= 0 && std::isprint(c)) {
        msg << c;
    } else {
        // We want to print the character (which is a signed char) as its octal value.
        // Casting directly to unsigned int incorrectly handles negative values:
        // For example, (char)-1 == 0xff == 255, but (unsigned int)-1 == 0xffffffff == 4294967295.
        // By first casting char to unsigned char, the number of set bits is preserved but the sign is changed.
        // Just casting to uint8_t also doesn't work, because the stringstream just treats it as char
        msg << '\\' << std::setfill('0') << std::setw(3) << std::right << std::oct;
        msg << static_cast<int>(static_cast<unsigned char>(c));
    }
    msg << "' in program";
    return msg.str();
}

template<typename T>
static yy::Parser::symbol_type
lex_int(const char *text, yy::location loc) {
    auto base = 10;
    auto str  = std::string(text);
    str.erase(remove(str.begin(), str.end(), '_'), str.end());
    if (str.size() > 2 && str[0] == '0') {
        // Parse base
        switch (str[1]) {
            case 'b': case 'B':
                base = 2;
                str = str.substr(2);
                break;
            case 'o': case 'O':
                base = 8;
                str = str.substr(2);
                break;
            case 'd': case 'D':
                base = 10;
                str = str.substr(2);
                break;
            case 'x': case 'X':
                base = 16;
                str = str.substr(2);
                break;
            default: break;
        }
    }
    auto end = str.find_first_of("uUiI");
    if (end != std::string::npos) {
        str = str.substr(0, end);
    }
    T result;
    if (str_to_int(str, result, base)) {
        std::stringstream ss;
        switch (base) {
            case 2:  ss << "0b"; break;
            case 8:  ss << "0o"; break;
            case 16: ss << "0x"; break;
            default: break;
        }
        ss << str;
        throw yy::Parser::syntax_error(loc, int_out_of_range<T>(ss.str(), base));
    }
    return yy::Parser::make_INT(result, loc);
}

namespace yy {

Scanner::Scanner(std::string path, std::istream &input)
    : yyFlexLexer()
    , path_{std::move(path)}
    , input_{input} {
    loc_.initialize(&path_);
    switch_streams(&input_);
}

Scanner::~Scanner() = default;

void
Scanner::set_debug_level(int l) {
    yy_flex_debug = l;
}

} // namespace yy
