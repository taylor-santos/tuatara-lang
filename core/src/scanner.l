%option debug
%option c++
%option noyywrap
%option never-interactive
%option nounput
%option batch
%option prefix="yy"
%option stack
%option nodefault
%option warn
%option nounistd
%option yyclass="Scanner"

/* Declare perf-report twice to enable minor performance loss reporting */
%option perf-report perf-report
%option verbose

%top{
// This block is inserted at the top of scanner.cpp

// Disable compiler-specific warnings for code generated by Flex
#if defined(__clang__)
#elif defined(__GNUC__) || defined(__GNUG__)
#elif defined(_MSC_VER)
#    include <stdint.h> // Prevent a ton of warning C4005: macro redefinition
#    pragma warning(disable:                                                                                           \
         4244 /* 'return': conversion from 'std::streamsize' to 'int', possible loss of data */                        \
     )
#endif

#include <sstream>
#include <iomanip>
#include <algorithm>

}

%{
// This block is inserted in the definitions section of scanner.cpp

#include "scanner.hpp"

#define LINE() {                                                                                                       \
    loc.lines(1);                                                                                                      \
}

#define YY_USER_ACTION {                                                                                               \
    loc_.step();                                                                                                       \
    loc_.columns(yyleng);                                                                                              \
}

static yy::Parser::symbol_type
lex_int(const char *yytext, yy::location loc);

static yy::Parser::symbol_type
lex_str(const char *yytext, yy::location loc);

static void
throw_unrecognized_char(char c, yy::location loc);

%}

ident_start    [a-z]
typename_start [A-Z]
ident          [_0-9a-zA-Z]

%%

%{
    // This block is executed every time yylex() is called.
%}

[\r]?[\n]?                          { loc_.lines(1); }
[[:blank:]]+                        { /* Ignore whitespace */ }
[/]{2}.*                            { /* Ignore comments */ }

[[:digit:]]([_]*[[:digit:]]+)*      { return lex_int(yytext, loc_); }
["][^\n\r]*["]                      { return lex_str(yytext, loc_); }

return                              { return yy::Parser::make_RETURN(loc_); }
struct                              { return yy::Parser::make_STRUCT(loc_); }
operator                            { return yy::Parser::make_OPERATOR(loc_); }

{ident_start}{ident}*               { return yy::Parser::make_IDENT(yytext, loc_); }
{typename_start}{ident}*            { return yy::Parser::make_TYPENAME(yytext, loc_); }

";"                                 { return yy::Parser::make_SEMICOLON(loc_); }
":"                                 { return yy::Parser::make_TYPE_DECL(loc_); }
":="                                { return yy::Parser::make_DEFINE(loc_); }
"::"                                { return yy::Parser::make_CONSTDEF(loc_); }
"="                                 { return yy::Parser::make_ASSIGN(loc_); }
","                                 { return yy::Parser::make_COMMA(loc_); }
"."                                 { return yy::Parser::make_DOT(loc_); }
"'"                                 { return yy::Parser::make_TICK(loc_); }

"("                                 { return yy::Parser::make_LPAREN(loc_); }
")"                                 { return yy::Parser::make_RPAREN(loc_); }
"{"                                 { return yy::Parser::make_LBRACE(loc_); }
"}"                                 { return yy::Parser::make_RBRACE(loc_); }
"["                                 { return yy::Parser::make_LBRACKET(loc_); }
"]"                                 { return yy::Parser::make_RBRACKET(loc_); }

"->"                                { return yy::Parser::make_ARROW(loc_); }
"=>"                                { return yy::Parser::make_BIGARROW(loc_); }

"$"                                 { return yy::Parser::make_DOLLAR(loc_); }
"!"                                 { return yy::Parser::make_BANG(loc_); }
"~"                                 { return yy::Parser::make_TILDE(loc_); }
"*"                                 { return yy::Parser::make_MUL(loc_); }
"/"                                 { return yy::Parser::make_DIV(loc_); }
"%"                                 { return yy::Parser::make_MOD(loc_); }
"+"                                 { return yy::Parser::make_PLUS(loc_); }
"-"                                 { return yy::Parser::make_MINUS(loc_); }
"<<"                                { return yy::Parser::make_LSHIFT(loc_); }
">>"                                { return yy::Parser::make_RSHIFT(loc_); }
"<"                                 { return yy::Parser::make_LT(loc_); }
"<="                                { return yy::Parser::make_LE(loc_); }
">"                                 { return yy::Parser::make_GT(loc_); }
">="                                { return yy::Parser::make_GE(loc_); }
"=="                                { return yy::Parser::make_EQ(loc_); }
"!="                                { return yy::Parser::make_NE(loc_); }
"&"                                 { return yy::Parser::make_BITAND(loc_); }
"^"                                 { return yy::Parser::make_BITXOR(loc_); }
"|"                                 { return yy::Parser::make_BITOR(loc_); }
"&&"                                { return yy::Parser::make_AND(loc_); }
"||"                                { return yy::Parser::make_OR(loc_); }

"---"                               { return yy::Parser::make_UNINIT(loc_); }

[-*/%+<>=&^|@#!~]+                  { return yy::Parser::make_SYMBOL(yytext, loc_); }

.                                   { throw_unrecognized_char(*yytext, loc_); }
<<EOF>>                             { return yy::Parser::make_EOF(loc_); }

%%

// This block is inserted at the bottom of scanner.cpp

static yy::Parser::symbol_type
lex_int(const char *yytext, yy::location loc) {
    try {
        auto text = std::string(yytext);
        text.erase(remove(text.begin(), text.end(), '_'), text.end());
        auto ull = std::stoull(text, nullptr, 10);
        if (ull <= std::numeric_limits<uint64_t>::max()) {
            // The c++ standard only guarantees that unsigned long long has *at least* 64 bits of precision.
            // Make sure that the conversion to uint64_t will not overflow.
            auto u64 = static_cast<uint64_t>(ull);
            return yy::Parser::make_INT(u64, loc);
        }
    } catch (...) {}
    std::stringstream ss;
    ss << "syntax error, " << yytext << " out of range of u64";
    throw yy::Parser::syntax_error(loc, ss.str());
}

static yy::Parser::symbol_type
lex_str(const char *yytext, yy::location loc) {

    try {
        auto text = std::string(yytext);
        text.erase(remove(text.begin(), text.end(), '_'), text.end());
        auto ull = std::stoull(text, nullptr, 10);
        if (ull <= std::numeric_limits<uint64_t>::max()) {
            // The c++ standard only guarantees that unsigned long long has *at least* 64 bits of precision.
            // Make sure that the conversion to uint64_t will not overflow.
            auto u64 = static_cast<uint64_t>(ull);
            return yy::Parser::make_INT(u64, loc);
        }
    } catch (...) {}
    std::stringstream ss;
    ss << "syntax error, " << yytext << " out of range of u64";
    throw yy::Parser::syntax_error(loc, ss.str());
}


static void
throw_unrecognized_char(char c, yy::location loc) {
    std::stringstream msg;
    msg << "stray '";
    if (c >= 0 && std::isprint(c)) {
        msg << c;
    } else {
        // We want to print the character (which is a signed char) as its octal value.
        // Casting directly to unsigned int incorrectly handles negative values:
        // For example, (char)-1 == 0xff == 255, but (unsigned int)-1 == 0xffffffff == 4294967295.
        // By first casting char to unsigned char, the number of set bits is preserved but the sign is changed.
        // Just casting to uint8_t also doesn't work, because the stringstream just treats it as char
        msg << '\\' << std::setfill('0') << std::setw(3) << std::right << std::oct;
        msg << static_cast<int>(static_cast<unsigned char>(c));
    }
    msg << "' in program";
    throw yy::Parser::syntax_error(loc, msg.str());
}

namespace yy {

Scanner::Scanner(const std::string *path, LineStream &input)
    : yyFlexLexer()
    , input_{input} {
    loc_.initialize(path);
    switch_streams(&input_);
}

Scanner::~Scanner() = default;

void
Scanner::set_debug_level(int l) {
    yy_flex_debug = l;
}

} // namespace yy
